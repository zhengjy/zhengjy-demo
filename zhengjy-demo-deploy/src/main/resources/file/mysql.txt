mysql引擎，都采用b+tree实现索引
	myisam:索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。
	innoDB:数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。
磁盘性能	
	InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
	系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
	InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB。

B-tree问题
	B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，
	当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。
	
	
索引不存储null值。
	单列索引不存储null值，复合索引不存储全为ｎｕｌｌ的值
	索引不能存储Null，所以对这列采用is null条件时，因为索引上根本没Null值，不能利用到索引，只能全表扫描。
为什么索引列不能存Null值
	1、索引是有序的。当一个空值进入索引时，无法确定其在索引中的位置。
	2、空值与空值不相等。当检索一个空值时，由于空值与空值并不相等，所以，无法在索引中找到期望的空值索引。
前导模糊查询不能利用索引(like '%XX'或者like '%XX%')
	假如有这样一列code的值为'AAA','AAB','BAA','BAB' ,如果where code like '%AB'条件，由于前面是模糊的，所以不能利用索引的顺序，必须一个个去找，看是否满足条件。这样会导致全全表扫描。
	如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。
	
索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引

B+Tree查找区间
	比如：查询首字母为f~t的所有单词。那么只需查到f开头的第一个单词fabric，然后沿着叶子节点的开始遍历，直到找到最后一个以t开头的单词为止。
	
	
二叉查找树：左子树的键值小于根的键值，右子树的键值大于根的键值。 如下，6是根节点，左边2、3、5都小于6，右边7、8都大于6
			6
	3			7
2		5			8