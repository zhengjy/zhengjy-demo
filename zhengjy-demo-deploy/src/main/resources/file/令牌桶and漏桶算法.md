### 令牌桶算法

​	在网络传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量均匀的速度向外发送。

**令牌桶算法在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在令牌桶算法中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，因此它适合于具有突发特性的流量。**

大小固定的令牌桶可自行以恒定的速率不断的产生令牌。如果令牌不被消耗，或者被消耗的速度小于产生的速度，令牌就会不断的新增，直到把桶填满。后面在产生的令牌就会从桶中溢出。最后桶中可以保存的最大令牌数永远不会超过桶的大小。

令牌桶机制基于令牌桶中是否存在令牌来指示什么时候可以发送流量。令牌桶中的每一个令牌都代表一个字节。如果令牌桶中存在令牌，则允许发送流量；如果令牌桶中不存在令牌，则不允许发送流量。如果突发门限被合理的配置并且令牌桶中有足够的令牌，那么流量可以以峰值速率发送。

![1545374346(1)](E:\develop\git_workspase\zhengjy-demo\zhengjy-demo-deploy\src\main\resources\file\md_img\1545374346(1).png)

1）假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中

2）假设桶中最多可以存放b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃

3）当流量以速率v进入，从桶中以速率v取令牌，拿到令牌的流量通过，拿不到令牌流量不通过，执行熔断逻辑

属性，熔断策略

​	3.1）它可以被丢弃。

​	3.2）他们可以排队放在队列中以便令牌桶中累计了足够多的令牌时在传输；

​	3.3）他们可以继续发送，但是需要特别标记，网络过载的时候可以将这些特殊标记丢弃。



```
public void testAcquire() {
      RateLimiter limiter = RateLimiter.create(1);

      for(int i = 1; i < 10; i = i + 2 ) {
          double waitTime = limiter.acquire(i);
          System.out.println("cutTime=" + System.currentTimeMillis() + " acq:" + i + " waitTime:" + waitTime);
      }
  }
```

输出结果：

```
cutTime=1535439657427 acq:1 waitTime:0.0
cutTime=1535439658431 acq:3 waitTime:0.997045
cutTime=1535439661429 acq:5 waitTime:2.993028
cutTime=1535439666426 acq:7 waitTime:4.995625
cutTime=1535439673426 acq:9 waitTime:6.999223
```

首先通过`RateLimiter.create(1);`创建一个限流器，参数代表每秒生成的令牌数，通过`limiter.acquire(i);`来以阻塞的方式获取令牌，当然也可以通过`tryAcquire(int permits, long timeout, TimeUnit unit)`来设置等待超时时间的方式获取令牌，如果超timeout为0，则代表非阻塞，获取不到立即返回。

从输出来看，RateLimiter支持预消费，比如在acquire(5)时，等待时间是3秒，是上一个获取令牌时预消费了3个两排，固需要等待3*1秒，然后又预消费了5个令牌，以此类推

**RateLimiter通过限制后面请求的等待时间，来支持一定程度的突发请求(预消费)**