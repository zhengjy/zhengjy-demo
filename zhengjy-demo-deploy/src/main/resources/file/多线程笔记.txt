线程安全定义：
	当多个线程访问一个类时，如果不考虑这些这些线程在“运行时”环境下的调度和交替运行，并且“不需要额外的同步及在调用方法代码不必做
其他的协调”，这个类的行为仍然是正确的，那么这个类就是线程安全的。
	只有资源竞争时才会导致线程不安全，因此无状态对象永远是线程安全的。
	
多线程性能问题:
	在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁的出现上下文的切换操作，这种操作将带来极大的开销；
保存和恢复执行上下文，丢失局部性，并且CPU时间将更多的花在线程调度而不是线程运行上。
多线程的并发问题：
	如果多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
		1、不在线程之间共享该状态变量。
		2、将状态变量修改为不可变的变量。
		3、在访问状态变量时使用同步。

线程的生命周期性能：
	线程生命周期的开销非常高。
	大量空闲的线程会占用许多内存，给垃圾回收带来压力。
	大量线程在竞争CPU资源时还将产生其他的性能开销。

锁机制存在问题：
	1)在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
	3)一个线程持有锁会导致其他所有需要此锁的线程挂起。
	3)如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。
	
锁分段：
	HashTable都是竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中的一部分数据，那么当多线程访问不同数据段的数据时，线程间就不会存在锁竞争，
从而可以有效的提高并发访问率，这就是ConcurrentHashMap使用的锁分段技术，首先将数据一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问
其中一段数据时，那么其他段的数据也能被其他线程访问。

锁分解:
	缩小锁的范围：锁分解的核心缩小无关的代码块，如果在一个方法中有一部分的代码与锁无关，一部分的代码与锁有关，那么可以缩小这个锁的范围，
这样锁操作的代码块减少，锁竞争的可能性也降低
	减少锁的粒度：如果一个锁需要保护多个互相独立的变量，那么可以将一个锁分解多个锁，并且每个锁保护一个变量。

ReentrantLock和synchronized区别：
		synchronized无法中断线程，ReentrantLock可以中断线程。
		synchronized在代码执行异常后，JVM自动释放锁。ReentrantLock不行，必须把unlock()释放锁方法写在finnaly中。
		在资源竞争不是很激烈时，synchronzid优于ReentrantLock，与之相反。
		ReadWriteLock实现了一种多读取操作以及单写入操作情况下的加锁规则。
	
并发技巧：
	所有的并发问题都归于如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全性。
	在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这么做？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在
对象中，更易于遵循同步策略。
	用锁来保护每个可变变量。
	当保护同一个不变性条件中的所有变量时，要使用同一个锁。
	在执行复合操作期间，要持有锁。
	如果从多个线程访问同一个可变变量时没有同步机制，那么程序会出现问题。
	在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。

ThreadLocal:
	ThreadLocal会为每个线程提供一个独立副本变量，从而隔离了多线程对数据访问的冲突，因为每个线程都拥有自己的变量副本，从而就没有必要对
该变量进行同步。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装到ThreadLocal中。

原子性：
	所谓的原子操作，是指操作过程中不会被中断，保证数据操作是以原子方式进行的。
	原子操作的描述是：多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。
	
锁的竞争时间:
	锁被持有的时间应该尽可能的短，因为锁的持有时间越长，那么在这个锁上发生竞争的可能性就越大。
	 降低锁的竞争：
		减少锁的持有时间。
		降低锁的请求频率。
		使用带有协调机制的独占锁，这些机制允许更高的并发性。
	
提升可伸缩性：
	减少锁的持有时间，降低锁的粒度，以及采用非独占的锁或非阻塞锁来代替独占锁。

闭锁：
	闭锁的作用相当于一扇门，在闭锁到达结束状态之前，折扇门一直关闭的，并且没有任何线程能通过，当到达结束状态时，折扇门会打开并允许所有的
线程通过，当闭锁到达结束状态后，将不会在改变状态，因此这扇门将永远保持打开状态。CountDownLatch是一种闭锁实现。

死锁：
	当一个线程永远不释放另外一个线程需要的资源就会导致死锁。
	如：线程A拿住A锁获取B锁，线程B拿住B锁获取A锁。就会导致死锁。
	避免：如果必须获取多个锁，那么在设计时必须考虑锁的顺序：尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循
这些协议。
	查找方法：找出什么地方将获取多个锁（使这个集合尽量小），然后对所有这些实例进行全局分析，从而确保它们在整个程序中获取锁的
顺序都保持一致。

活锁:
	活锁描述的是线程总是尝试某项操作却总是失败的情况。这种情况下尽管线程没有阻塞，但是任务却不能正常执行。
	如：死循环中总尝试做某些事情，结果却总是失败，线程永远不能跳出循环。

内部锁：----------
	java语言是通过synchronized关键字来保证原子性。这是因为Object都有一个隐含的锁，这个也称作监视器对象。在进入synchronized之前
自动获取此内部锁，而一旦离开此方法都会自动释放锁。显然这是一个独占锁，每个锁请求之间都是互斥的。


对象锁和类锁：
	对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个锁。

线程饥饿：
	当线程由于无法访问他所需要的资源而不能继续执行时，就发生了“饥饿”。

独占锁的解决方法：
	1.ReadWriteLock实现了一种多读取操作以及单写入操作情况下的加锁规则：如果是多读取操作都不会修改共享资源，那么这些读取操作可以
同时访问该共享资源，但在执行写入操作时必须以独占方式来获取锁。对于读取操作占多数的数据结构，ReadWriteLock可以提供比独占锁更改的
并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要加锁操作，
	2.原子变量可以当做静态计数器、序列发生器

吞吐量：指一组并发任务中已完成任务所占的比例。
响应性：指请求从发出到完成之间的时间。
可伸缩性：指在增加更多资源的情况下（通常指CPU），吞吐量（或者缓解短缺）的提升情况。	

开放调用：
	如果在调用某个方法时不需要持有锁，那么这种调用称为开放调用。
	依赖于开放调用的类通常能表现出更好的行为，并且与那些在调用方法时需要持有锁的类相比，也更易与编写。
	
	
volatile：
	volatile并不能保证线程安全的，也就是说volatile字段的操作不是原子性的,volatile变量只能保证可见性（一个线程修改后其他线程能够
立即看到此变化后的结果），要想保证原子性，目前只能加锁。
	
线程池：
	好处.1)在线程池中执行任务比为每个任务分配一个线程优势更多。通过重用现有的线程而不是创建新线程，可以在处理多个请求时
分摊创建和销毁线程中产生巨大的开销。
	好处.2)当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。



notify的使用条件：
	1.所有等待线程的类型相同。只要一个条件谓词与条件队列相关，并且每个线程在wait返回后将执行相同的操作。
	2.单进单出。在条件变量上的每次通知，最多只能唤醒一个线程来执行。


synchronized原理：
		在JVM内部，为了提高效率，同时运行的每个线程都会有它正在处理的数据的缓存副本，当我们使用snchronized进行同步的时候，真正被同步的是在不同
线程中表示被锁定对象的内存块（副本数据会保持和主内存的同步），简单的说就是在同步块或同步方法执行完后，对被锁定的对象做的任何修改要在释放锁之前
写回主内存；在进入同步快得到锁知乎，被锁定对象的数据是从主内存读取出来的，持有锁的线程的数据副本一定和主内存中的数据视图是同步的。
		
不可重入锁：
	一个类有两个方法method1和method2都是synchronized修饰了，假如某一时刻，线程A执行了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized
	不具备可冲入性，此时线程A需要重写申请锁。但是这就造成一个问题，因为线程A已经持有了该对象的锁，而又申请获取该对象的锁，这样就会线程A一直等待永远获取不到锁。而由于
	synchronized和Lock都具备可重入性，所以不会发生上述情况。

可重入锁：
	当一个线程持有某个synchronized方法时，比如说method1，而method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2.

公平锁和不公平锁：
	公平锁：公平锁即尽量以请求锁的顺序来获取锁。比如同时有多个线程在等待一个锁，当这个锁被释放时，等待最长时间的线程(最先请求的线程)会获取该锁，这种是公平锁。
	非公平锁：即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或一些线程永远获取不到锁。
	在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。
　　而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁

读写锁
　　读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。
　　正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。
　　ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。
　　可以通过readLock()获取读锁，通过writeLock()获取写锁。
	
interrupt线程中断：
	对线程中断的正确理解是：他并不会真正中断一个正在运行的线程，而只是发出中断请求，然后由下一个适合的时刻中断自己。
	
	
独占锁:
	锁在一个时间点只能被一个线程锁占有。ReentrantReadWriteLock.WriteLock也是独占锁。
共享锁：
	能被多个线程同时拥有，能被共享的锁。ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch和Semaphore都是共享锁
自旋锁：
	指当前一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检查锁是否释放，而不是进入线程挂起或睡眠。
	
JAVA内存模型（JAVA Memory Model）
	JMM主要是为了规定线程与内存之间的一些关系。根据JMM的设计，系统存在一个主内存，Java中所有实例变量都存储在主内存中，
对于所有线程都是共享的。每条线程都用自己的工作内存，工作内存由缓存和堆栈两部分组成，缓存中保存的是主内存中变量的拷贝，
缓存可能并不总和主内存同步，也就是缓存中变量的修改可能没有立刻写到主内存中；堆栈中保存的是线程的局部变量，线程之间无法相互
直接访问堆栈中的变量

守护线程
	指在程序运行的时候后台提供一种通用的线程，如垃圾回收线程就是一种，这种线程不属于程序不可缺少的一种，当非守护线程结束的时候，同时进程会杀死
	所有守护线程。将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。 thread.setDaemon(true)必须在thread.start()之前设置。
	
指令重排序
	在线程A中有两条语句对这两个共享变量进行赋值操作:
		a = 1;b = 2;
	假设当线程A对a进行复制操作的时候发现这个变量在主内存已经被其它的线程加了访问锁，那么此时线程A怎么办？等待释放锁？不，等待太浪费时间了，它会去尝试进行b的赋值操作，
	b这时候没被人占用，因此就会先为b赋值，再去为a赋值，那么执行的顺序就变成了:
		b = 2;
		a = 1;

共享对象可见性

如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不接见的。

想象一下，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它
CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。
	
-----局部变量在每个线程中都有各自的实例。	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
HashMap底层是用一个Entry数组实现的,
entry数组有4个属性：key和value是存储的数据,hash是元素key的hash后形成的（映射到数组上的hash）,next是指向下一个元素的索引。








-------------------------------------------------------------------

SpringMVC的控制器是从请求中获得的对象都是以方法的参数传入保证了线程安全。
Status2中作为控制器的Action类都是为每个类创建一个实例。


秒杀 看活动库存多少设置多少个队列，超过队列拒绝请求
	
	