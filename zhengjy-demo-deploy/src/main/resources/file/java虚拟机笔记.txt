hotspot虚拟机

什么是JDK：
	可以把java程序设计语言、java虚拟机、javaAPI类库这个三部分统称为JDK(Java Development Kit)，JDK是用于支持java程序开发
的最小环境。

什么是JRE:
	可以把JAVA API类库中的 JAVA SE API子集和Java虚拟机统称为JRE(java Runtime Environment) JRE，JRE是支持java程序运行的
标准环境。

虚拟机运行时数据区域:
	java虚拟机在执行java程序的过程中会把它管理的内存划分若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，
有的区域随着虚拟机的进程启动而存在，有些区域依赖用户线程的启动和结束而建立和销毁。

程序计数器：
	程序计数器是一个较小的内存空间。它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的
值来选择下一条需要执行的字节码指令、分支、循环、跳转、异常恢复等基础功能都需要依赖这个计数器来完成。
	由于java虚拟机多线程是通过线程的轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程
中的指令。因此，为了线程切换恢复能执行到正确的位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，
我们称这类内存区域为“线程私有“内存。

java虚拟机栈：
	java虚拟机栈是线程私有的，它的生命周期和线程相同。虚拟机描述的是java方法执行的内存模型：每个方法在执行的同时都会创建栈帧用于存储
局部变量表、操作数帧、动态链接、方法出口灯信息。每个方法从调用直至执行完成的过程，就对应着一个帧栈在虚拟机中入栈和出栈的过程。

本地方法栈：
	本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方法栈
则为虚拟机使用到Native方法服务。

java堆：
	java堆是java虚拟机管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。次内存区域的唯一目的就是存放对象
对象的实例，几乎所有对象的实例都会在这里分配内存。

方法区：
	方法区，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

运行时常量池：
	运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息，还有一项信息是常量池，用于存放编译期生成的各种字面量
和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

类加载器：虚拟机只加载程序执行时所需要的类文件。假设程序MyProgram.class开始运行，下面是虚拟机执行的步骤：
	1)虚拟机有一个用于加载类文件的机制，例如，从磁盘上读取文件或者请求web上的文件；它使用该机制来MyProgram.class类文件的内容。
	2)如果MyProgram类拥有类型为另一个类的域，或者是超类，那么这个类文件也会被加载。（加载某个类所依赖的所有类的过程称为类的解析）
	3)接着，虚拟机执行MyProgram中的main方法(它是静态的，无需要创建类的实例)。
	4)如果main方法或者main方法调用的方法要用到更多的类，那么接下来就会加载这些类。

对象的创建：
	虚拟机遇到new的指令时，首先将会检查这个指令的参数是否能在常连池中定位到一个类的符合引用，并且检查这个符合引用代表的类是否已被加载、解析
和初始化过。如果没有，那么必须先执行相应的类加载过程。加载通过后，虚拟机将从一块确定大小的内存从java堆中划分出来。内存分配完后，虚拟机需要
将分配到内存空间都初始化为零值。接下来，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗
、对象的GC分代年龄等信息。上面的工作都完成之后，从虚拟机的视角来看，一个新的对象产生了，但从java的视角对象才刚刚开始——init方法还没执行，所有
的字段都还是零。所以一般来说，执行new指令之后会接着执行init方法，把对象安装程序猿的意愿进行初始化，这样一个真正的对象才算产生。

对象的内存布局：对象的内存中存储的布局可以分为3块区域：
	对象头：主要包括对象自身的运行元数据，比如哈希码、GC分代年龄、锁状态标志等。
	实例数据：它是对象真正存储的有效信息，包括程序代码中定义的各种类型字段（包括从父类继承下来和本身）
	对齐填充：它是不必要的存在，仅仅起着占位符的作用



java对象GC收回：
	给对象加添加一个引用计数器，没有有一个地方引用它时，计数器就加1，当失效时，计数器就减1;任何时刻计数器为0的对象就是不可能再被使用的。

分代垃圾回收：
		在JVM的内存空间中把堆内存分为年老代和年轻代。将大量（90%以上）创建了没多久就会消失的对象存储在年轻代，而年老代中存放生命周期长久的实例
	对象。简单讲，就是生命期短的对象放在一起，将少数生命周期长的对象放在一起，分别采用不同的回事策略。生命期短的对象回收比较高，生命期长的对象
	采用比较低的回收频率，生命期短的对象尝试回收几次发现还存活，则被移到另外一个地方存起来。

垃圾收集算法：
	标记-清除算法：
		首先标记出所有需要回收的对象，在标记完后统一回收所有被标记的对象。有两个不足：一是效率问题，标记和两个过程的效率都不高；另一个是空间
	问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配的较大对象时，无法找到足够的连续内存而不得不
	提前触发另一个垃圾回收动作。

	复制算法：
		收集算法，他可以将可用内存按容量划分为大小相等的两块，每次只使用一块。当这一块内存用完了，就将还存活的对象复制到另外一块上面，然后再把
	已使用的内存空间一次清掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存
	即可，实现简单，运行高效。只是这种算法将内存缩小为原来的一半，未免太高了。

	标记-整理算法：
		标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一段移动，然后直接清理掉端边界以外
	的内存。

垃圾收集器：
	Serial收集器:单线程收集器，但是它的“单线程”的意义并不仅仅说明他只使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集
时，必须暂停其他所有的工作线程，知道收集结束。
	ParNew收集器：ParNew收集器其实就是Serial收集器的多线程版本。


内存分配与回收策略：对象的内存分配，就是堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。
	对象优先在Eden分配：
		大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间进行分配，虚拟机将发起一次Minor GC(新手代 GC)。
		新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性。所以Minor GC非常频繁，一般回收的速度也快。
		老年代GC（Major GC/Full GC）:指发生在老年代的GC，出现Major GC，经常会伴随着至少一次的Minor GC（但非决对的，在Parallel Scavenge收集
	器的收集策略里就有直接进行Major GC的策略选择过程。）。Major GC的速度一般会比Minor GC慢10倍左右。

	大对象直接进入老年代:
		虚拟机提供一个-XX:PretenureSizeThreeshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免Eden区以及两个Survivor区之间
	发生大量的内存复制。

	长期存活的对象进入老年代：
		虚拟机给每个对象定义了对象年龄计数器。如果对象在Eden出生后仍然存活，并且能被Survivor容纳的话，被移动到Survivor空间中，并且年龄对象设置1.
对象在Servivor区中每熬过一次，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就会被晋升为老年代。对象的晋升年龄阀值，可以通过
-XX:MaxTenuringThreshold设置

	动态对象年龄判断：
		为了更换适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold 才晋升老年代，如果Survivor空间中相同
	年龄所有对象大小的总大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。

JDK的命令行工具：
	虚拟机进程状况工具（jps）：同一个java虚拟机只能运行一个进程。如果启动了多个虚拟机进程，可以依赖jps命令显示主类的功能才能区分。
		jps -q 只输出LVMID，省略主类名称
		jps -m 输出进程启动时传递主类 main()函数的参数
		jps -l 输出主类的全名，如果进程执行的是Jar包，输出Jar路径
		jps -v 数据虚拟机进程启动时JVM参数

	虚拟机统计信息监视工具（jstat）：jstat是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机进程中的类装载、内存、垃圾
收集、JIT编等运行数据。
	jstat -gcutil 8904 1000 5
	S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT
	0.00  50.00  22.83  49.18  99.61     39    0.306     0    0.000    0.306
	两个Survivor(SO,S1，Survivor0,Survivor1)里面都是空的
	Enden区(E，标识Enden)使用了22.83%的空间
	老年代(O,表示old)使用了49.18空间
	永久代(P,表示Permanent)使用了99.61空间
	程序运行以来共发生Minor GC(YGC，标识Young GC)39次,(YGCT)总消耗了0.306秒。
	发生Full GC(FGC,表示 Full GC)0次，Full GC总耗时(FGCT,表示Full GC Time) 为0.000秒。
	所有的GC总耗时(GCT,表示GC Time)为0.306秒。

	Java配置信息工具(jinfo)：jinfo的作用是实时的查看和调整虚拟机各项参数。可以使用-flag[+|-]name或者-flag name=value修改一部分运行期可写的
虚拟机参数值。


JAVA类型加载的过程:
	加载、验证、准备、解析、初始化
	加载：
		通过类的全限定名来获取定义此类的字节流。
		将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
		在内存中生成一个代表这个类的java.lang.Clas对象，作为方法区这个类的各种访问入口。
	验证：
		文件格式的验证，符合Class文件格式的规范
	准备：
		为类变量分配内存，并设置类变量的初始值
	解析：
		虚拟机将常量池内的符合引用替换为直接引用，（比如String s="xxx"，将s的地址指向xxx）
	初始化：
		当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先初始化其父类的初始化
		为静态变量赋值
		
		
类的实例化顺序
	对象初始化的顺序，先静态方法，再构造方法，每个又是先基类后子类。


	
ClassLoader加载器：
		bootstrapClassLoader是加载java_home/jre/lib目录下的个别jar包（不是全部）
		extClassLoader是加载java_home/jre/lib/ext目录下的jar包
		AppClassLoader是加载classpath中指定的jar包
		自定义加载器

CMS过程：
初始标记(STW initial mark)
并发标记(Concurrent marking)
并发预清理(Concurrent precleaning)
重新标记(STW remark)
并发清理(Concurrent sweeping)
并发重置(Concurrent reset)
初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。
并发标记 ：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。
并发预清理 ：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。
重新标记 ：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从"跟对象"开始向下追溯，并处理对象关联。
并发清理 ：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。
并发重置 ：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。



引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。


溢出经常性的问题:
1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
3.代码中存在死循环或循环产生过多重复的对象实体；
4.启动参数内存值设定的过小
5.有些流没关闭


































内存溢出的解决方案：
第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
重点排查以下几点：
1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
2.检查代码中是否有死循环或递归调用。
3.检查是否有大循环重复产生新对象实体。



java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0
	-Xmx3550m：设置JVM最大可用内存未为3550M
	-Xms3550m：设置JVM最小内存为3550m。此值可用设置与-Xmx相同，以避免每次垃圾回收完后JVM重新分配内存。
	-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻大小+年老代大小+持久化大小。持久化一般固定大小为
64m，所以增大年轻代后，将会减少年老代大小。此值对系统性能影响较大。
	-Xss128k：设置每个线程堆栈大小。
	-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久化）。设置为4，则年轻代与年老代所占值为


	–XX:PermSize=64m //最小堆大小
    –XX:MaxPermSize=128m //最大堆大小

	-XX:MaxTenuringThreshold=1 设置进入老年代的阀值，如果是1，就会经历过Survivor1次就会进入老年代。
	-XX:PretenureSizeThreeshold=1024 设置新生代分配的内存大于1024k就直接分配到老年代区。
	